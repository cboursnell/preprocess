#!/usr/bin/env ruby

## # # # # # # # # # # # # #
## mrna pipeline
##
## can run any of these
##   trimmomatic
##   skewer
##   bayeshammer
##   khmer
##   bbnorm
##   more to come!
##
## created: 2014-05-27 Chris Boursnell (cmb211@cam.ac.uk)
##
## # # # # # # # # # # # # #

require 'trollop'
require 'preprocessor'
require 'set'
require 'json'

opts = Trollop::options do
  version "v0.3"
  banner <<-EOS
  mRna preprocessor pipeline

  author: Chris Boursnell (cmb211@cam.ac.uk)
  EOS
  opt :left, "Comma separated list of fastq files (can be gzipped)",
      :type => String
  opt :right, "Comma separated list of fastq files (can be gzipped)",
      :type => String
  opt :name, "Name prefix for output files (not used if input is used)",
      :type => String,
      :default => "output"
  opt :input, "Input file describing fastq files. Ignored if left and right specified",
      :type => String
  opt :output, "Directory where output files go",
      :type => String
  opt :threads, "Number of threads to use",
      :default => 1,
      :type => :int
  opt :memory, "Memory to use in GB",
      :default => 4,
      :type => :int
  # opt :filter, "Which filter program to use (none|facs)",
  #     :default => "facs",
  #     :type => String
  opt :trimmer, "Which trimming program to use (none|trimmomatic|skewer)",
      :default => "trimmomatic",
      :type => String
  opt :correction, "Which read error correction program to use (none|hammer)",
      :default => "hammer",
      :type => String
  opt :normalise, "Which digital normalisation program to run (none|khmer|bbnorm)",
      :default => "bbnorm",
      :type => String
  opt :filter_fasta, "A fasta file of sequences to filter against",
      :type => String
  opt :minlen, "The minimum length for trimmed sequences",
      :default => 40,
      :type => :int
  opt :kmer, "The kmer size to use for digital normalisation",
      :default => 23,
      :type => :int
  opt :cutoff, "The coverage cutoff to use for digital normalisation",
      :default => 20,
      :type => :int
  opt :tables, "The number of hash tables to use for digital normalisation",
      :default => 3,
      :type => :int
  opt :continue, "Try to continue pipeline",
      :default => false
  opt :verbose, "Be verbose"
  opt :morehelp, "Get help on how to format the input file"
end

if opts.morehelp
  puts "The input file should contain a line describing each input fastq file"
  puts "Each line should contain four fields separated by commas"
  puts "   1) Name of experiment"
  puts "   2) Path to the fastq file"
  puts "   3) What rep this file belongs to (integer)"
  puts "   4) What type of sample this is (eg cell type or WT/M)"
  puts "   5) Which pair of paired reads. (integer, either 1 or 2)"
  puts "eg:"
  puts "rice,fastq/BS-1-R1.fastq,1,BS,1"
  puts "rice,fastq/BS-1-R2.fastq,1,BS,2"
  puts "rice,fastq/M-1-R1.fastq,1,M,1"
  puts "rice,fastq/M-1-R2.fastq,1,M,2"
  exit(1)
end

if opts.left and opts.right
  opts.left.split(",").each do |file|
    Trollop::die :input, "must exist" if !File.exist?(file)
  end
  opts.right.split(",").each do |file|
    Trollop::die :input, "must exist" if !File.exist?(file)
  end
else
  Trollop::die "Must specify input" if !opts.input
  Trollop::die :input, "must exist" if !File.exist?(opts.input) if opts.input
end
Trollop::die "Must specify output" if !opts.output
if opts.continue and !Dir.exist?(opts.output)
  Trollop::die :output, "must exist"
elsif !opts.continue and Dir.exist?(opts.output)
  Trollop::die :output, "mustn't exist"
end

preprocessor = Preprocessor::Preprocessor.new(opts.output, opts.verbose,
                                                 opts.threads, opts.memory)

if opts.continue
  # load log from output directory
  preprocessor.data = JSON.parse(
    File.open(File.join(opts.output, "log")).readlines.join,
    :symbolize_names => true
  )
elsif opts.left and opts.right
  preprocessor.load_reads(opts.left, opts.right, opts.name)
else
  preprocessor.load_input(opts.input)
end

if opts.continue and preprocessor.data[0][:processed][:unzip]
else
  preprocessor.gunzip
end

if opts.continue and preprocessor.data[0][:processed][:trim]
  puts "already completed #{preprocessor.data[0][:processed][:trim]}"
else
  if opts.trimmer == "none"
  elsif opts.trimmer == "trimmomatic"
    preprocessor.trimmomatic(opts.minlen, 4, 15, 15, 15, 2)
  elsif opts.trimmer == "skewer"
    preprocessor.skewer(25, 0, opts.minlen)
  else
    raise RuntimeError.new("#{opts.trimer} is not a valid input to trimmer")
  end
end

if opts.continue and preprocessor.data[0][:processed][:correction]
  puts "already completed #{preprocessor.data[0][:processed][:correction]}"
else
  if opts.correction == "none"
  elsif opts.correction == "hammer"
    preprocessor.hammer
  else
    raise RuntimeError.new("#{opts.correction} is not a valid input to correction")
  end
end

if opts.continue and preprocessor.data[0][:processed][:normalise]
  puts "already completed #{preprocessor.data[0][:processed][:normalise]}"
else
  if opts.normalise == "none"
  elsif opts.normalise == "bbnorm"
    preprocessor.bbnorm(opts.kmer, opts.cutoff, 8, opts.tables)
  elsif opts.normalise == "khmer"
    preprocessor.khmer(opts.kmer, opts.cutoff, opts.tables)
  else
    raise RuntimeError.new("#{opts.normalise} is not a valid input to normalise")
  end
end

set = Set.new
preprocessor.data.each do |hash|
  set << hash[:current]
  set << hash[:unpaired] if hash[:unpaired].length > 0 if hash[:unpaired]
end
puts "Final output files:"
set.each do |file|
  puts "  #{file}"
end