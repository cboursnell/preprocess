#!/usr/bin/env ruby

## # # # # # # # # # # # # #
## mrna pipeline
##
## trimmomatic
## bayeshammer (optional)
## khmer
##
## created: 2014-05-27 Chris Boursnell (cmb211@cam.ac.uk)
##
## # # # # # # # # # # # # #

#require 'rubygems'
require 'trollop'
require 'preprocessor'

opts = Trollop::options do
  version "v0.2"
  banner <<-EOS
  mRna preprocessor pipeline

  author: Chris Boursnell (cmb211@cam.ac.uk)
  EOS
  opt :input, "Input file describing fastq files",
      # :required => true,
      :type => String
  opt :output, "Directory where output files go",
      # :required => true,
      :type => String
  opt :threads, "Number of threads to use",
      :default => 1,
      :type => :int
  opt :memory, "Memory to use in GB",
      :default => 4,
      :type => :int
  opt :no_trim, "Don't trim the input files"
  opt :no_hammer, "There is no time for hammertime"
  opt :no_khmer, "Don't run digital normalisation"
  opt :minlen, "The minimum length for trimmed sequences",
      :default => 40,
      :type => :int
  opt :kmer, "The kmer size to use for khmer",
      :default => 23,
      :type => :int
  opt :cutoff, "The coverage cutoff to use for khmer",
      :default => 20,
      :type => :int
  opt :buckets, "The bucket size to use for khmer",
      :default => 4,
      :type => :int
  opt :verbose, "Be verbose"
  opt :morehelp, "Get help on how to format the input file"
end

if opts.morehelp
  puts "The input file should contain a line describing each input fastq file"
  puts "Each line should contain four fields separated by commas"
  puts "   1) Path to the fastq file"
  puts "   2) What rep this file belongs to (integer)"
  puts "   3) What type of sample this is (eg cell type or WT/M)"
  puts "   4) Which pair of paired reads. (integer, either 1 or 2)"
  puts "eg:"
  puts "fastq/BS-1-R1.fastq,1,BS,1"
  puts "fastq/BS-1-R2.fastq,1,BS,2"
  puts "fastq/M-1-R1.fastq,1,M,1"
  puts "fastq/M-1-R2.fastq,1,M,2"
  exit
else
  Trollop::die :input, "must exist" if !File.exist?(opts.input) if opts.input
  Trollop::die :output, "must exist" if !Dir.exist?(opts.output) if opts.output

  preprocessor = Preprocessor.new(opts.input, opts.output, opts.verbose,
    opts.threads, opts.memory)

  preprocessor.trim(opts.minlen, 4, 15, 15, 15, 2) if !opts.no_trim

  preprocessor.hammer if !opts.no_hammer

  preprocessor.khmer(opts.kmer, opts.cutoff, opts.buckets) if !opts.no_khmer
end